
import { BitcoinTransactionParser, BitcoinTransaction, VulnerabilityResult, ECDSASignature } from './bitcoinParser';

export class VulnerabilityScanner {
  private static rValueDatabase = new Map<string, { txid: string; inputIndex: number; address?: string }[]>();
  private static addressUsageTracker = new Map<string, { txids: string[]; firstSeen: Date; lastSeen: Date }>();

  static async scanTransaction(txData: string | BitcoinTransaction): Promise<VulnerabilityResult[]> {
    const transaction = typeof txData === 'string' 
      ? BitcoinTransactionParser.parseRawTransaction(txData)
      : txData;

    const vulnerabilities: VulnerabilityResult[] = [];

    // Scan for different vulnerability types
    vulnerabilities.push(...this.detectRValueReuse(transaction));
    vulnerabilities.push(...this.detectAddressReuse(transaction));
    vulnerabilities.push(...this.detectDustAttacks(transaction));
    vulnerabilities.push(...this.detectNonStandardScripts(transaction));
    vulnerabilities.push(...this.detectOpReturnSpam(transaction));

    return vulnerabilities;
  }

  private static detectRValueReuse(transaction: BitcoinTransaction): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];

    transaction.inputs.forEach((input, inputIndex) => {
      if (!input.signatures || input.signatures.length === 0) return;

      input.signatures.forEach(signature => {
        const rValue = signature.r;
        const existingUses = this.rValueDatabase.get(rValue) || [];

        if (existingUses.length > 0) {
          // R-value reuse detected!
          vulnerabilities.push({
            type: 'r_reuse',
            severity: 'critical',
            description: 'ECDSA R-value reuse detected - Private key may be recoverable',
            details: `R-value ${rValue.substring(0, 16)}... has been used in multiple signatures. This allows mathematical recovery of the private key.`,
            affectedInputs: [inputIndex],
            rValue: rValue,
            addresses: existingUses.map(use => use.address).filter(Boolean) as string[]
          });

          console.log(`ðŸš¨ CRITICAL: R-value reuse detected!`);
          console.log(`R-value: ${rValue}`);
          console.log(`Current tx: ${transaction.txid}, input ${inputIndex}`);
          console.log(`Previous uses:`, existingUses);
        }

        // Store this R-value usage
        if (!this.rValueDatabase.has(rValue)) {
          this.rValueDatabase.set(rValue, []);
        }
        this.rValueDatabase.get(rValue)!.push({
          txid: transaction.txid,
          inputIndex,
          address: this.extractAddressFromInput(input)
        });
      });
    });

    return vulnerabilities;
  }

  private static detectAddressReuse(transaction: BitcoinTransaction): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];
    const addressesInTx = new Set<string>();

    // Extract addresses from outputs
    transaction.outputs.forEach((output, outputIndex) => {
      const address = this.extractAddressFromOutput(output);
      if (address) {
        addressesInTx.add(address);

        // Check if address has been used before
        const usage = this.addressUsageTracker.get(address);
        if (usage && usage.txids.length > 0) {
          vulnerabilities.push({
            type: 'address_reuse',
            severity: 'medium',
            description: 'Address reuse detected',
            details: `Address ${address} has been used in ${usage.txids.length + 1} transactions. This reduces privacy and makes transaction linking easier.`,
            affectedOutputs: [outputIndex],
            addresses: [address]
          });
        }

        // Update usage tracking
        if (!this.addressUsageTracker.has(address)) {
          this.addressUsageTracker.set(address, {
            txids: [],
            firstSeen: new Date(),
            lastSeen: new Date()
          });
        }
        const tracker = this.addressUsageTracker.get(address)!;
        tracker.txids.push(transaction.txid);
        tracker.lastSeen = new Date();
      }
    });

    return vulnerabilities;
  }

  private static detectDustAttacks(transaction: BitcoinTransaction): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];
    const dustThreshold = 0.00000546; // 546 satoshis

    const dustOutputs = transaction.outputs
      .map((output, index) => ({ output, index }))
      .filter(({ output }) => output.value <= dustThreshold && output.value > 0);

    if (dustOutputs.length > 3) {
      vulnerabilities.push({
        type: 'dust_attack',
        severity: 'medium',
        description: 'Potential dust attack detected',
        details: `Transaction contains ${dustOutputs.length} dust outputs (â‰¤${dustThreshold} BTC). This may be an attempt to spam the network or de-anonymize users.`,
        affectedOutputs: dustOutputs.map(({ index }) => index)
      });
    }

    return vulnerabilities;
  }

  private static detectNonStandardScripts(transaction: BitcoinTransaction): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];

    transaction.outputs.forEach((output, outputIndex) => {
      if (output.type === 'NON_STANDARD') {
        vulnerabilities.push({
          type: 'non_standard',
          severity: 'low',
          description: 'Non-standard script detected',
          details: `Output ${outputIndex} uses a non-standard script pattern that may not be accepted by all nodes.`,
          affectedOutputs: [outputIndex]
        });
      }
    });

    return vulnerabilities;
  }

  private static detectOpReturnSpam(transaction: BitcoinTransaction): VulnerabilityResult[] {
    const vulnerabilities: VulnerabilityResult[] = [];

    const opReturnOutputs = transaction.outputs
      .map((output, index) => ({ output, index }))
      .filter(({ output }) => output.type === 'NULL_DATA');

    if (opReturnOutputs.length > 1) {
      vulnerabilities.push({
        type: 'op_return_spam',
        severity: 'low',
        description: 'Multiple OP_RETURN outputs detected',
        details: `Transaction contains ${opReturnOutputs.length} OP_RETURN outputs, which may indicate data spam or inefficient use of blockchain space.`,
        affectedOutputs: opReturnOutputs.map(({ index }) => index)
      });
    }

    // Check for large OP_RETURN data
    opReturnOutputs.forEach(({ output, index }) => {
      if (output.scriptPubKey && Buffer.from(output.scriptPubKey, 'hex').length > 80) {
        vulnerabilities.push({
          type: 'op_return_spam',
          severity: 'medium',
          description: 'Large OP_RETURN data detected',
          details: `Output ${index} contains ${Buffer.from(output.scriptPubKey, 'hex').length} bytes of OP_RETURN data, exceeding standard limits.`,
          affectedOutputs: [index]
        });
      }
    });

    return vulnerabilities;
  }

  private static extractAddressFromInput(input: any): string | undefined {
    // Simplified address extraction - in a real implementation,
    // this would properly decode various script types
    return undefined;
  }

  private static extractAddressFromOutput(output: any): string | undefined {
    // Simplified address extraction - in a real implementation,
    // this would properly decode P2PKH, P2SH, etc.
    if (output.type === 'P2PKH' && output.decodedScript && output.decodedScript.length >= 3) {
      return `mock_address_${output.decodedScript[2].substring(0, 8)}`;
    }
    return undefined;
  }

  static getRValueStatistics() {
    const totalRValues = this.rValueDatabase.size;
    const reusedRValues = Array.from(this.rValueDatabase.entries())
      .filter(([_, uses]) => uses.length > 1).length;
    
    return {
      totalRValues,
      reusedRValues,
      reusePercentage: totalRValues > 0 ? (reusedRValues / totalRValues) * 100 : 0
    };
  }

  static getAddressStatistics() {
    const totalAddresses = this.addressUsageTracker.size;
    const reusedAddresses = Array.from(this.addressUsageTracker.entries())
      .filter(([_, usage]) => usage.txids.length > 1).length;

    return {
      totalAddresses,
      reusedAddresses,
      reusePercentage: totalAddresses > 0 ? (reusedAddresses / totalAddresses) * 100 : 0
    };
  }
}
