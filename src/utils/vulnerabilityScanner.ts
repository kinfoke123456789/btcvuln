import { BitcoinTransaction, TransactionInput, TransactionOutput, VulnerabilityResult, ECDSASignature } from './bitcoinParser';
import { PrivateKeyRecovery } from './privateKeyRecovery';

export class VulnerabilityScanner {
  static async scanTransaction(transaction: BitcoinTransaction): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    // Perform vulnerability detections
    const rReuseVulnerabilities = await this.detectRValueReuse(transaction);
    const addressReuseVulnerabilities = await this.detectAddressReuse(transaction);
    const dustAttackVulnerabilities = await this.detectDustAttacks(transaction);
    const nonStandardVulnerabilities = await this.detectNonStandardOutputs(transaction);
    const opReturnSpamVulnerabilities = await this.detectOpReturnSpam(transaction);

    vulnerabilities.push(...rReuseVulnerabilities);
    vulnerabilities.push(...addressReuseVulnerabilities);
    vulnerabilities.push(...dustAttackVulnerabilities);
    vulnerabilities.push(...nonStandardVulnerabilities);
    vulnerabilities.push(...opReturnSpamVulnerabilities);

    return vulnerabilities;
  }

  private static async detectOpReturnSpam(transaction: BitcoinTransaction): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    transaction.outputs.forEach((output, index) => {
      if (output.type === 'NULL_DATA' && output.scriptPubKey.length > 10) {
        vulnerabilities.push({
          type: 'op_return_spam',
          severity: 'low',
          description: 'Potential OP_RETURN spam output detected',
          details: `OP_RETURN output found at index ${index} with scriptPubKey: ${output.scriptPubKey}`,
          affectedOutputs: [index]
        });
      }
    });

    return vulnerabilities;
  }

  private static async detectNonStandardOutputs(transaction: BitcoinTransaction): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    transaction.outputs.forEach((output, index) => {
      if (output.type === 'NON_STANDARD') {
        vulnerabilities.push({
          type: 'non_standard',
          severity: 'medium',
          description: 'Non-standard output script detected',
          details: `Non-standard output found at index ${index} with scriptPubKey: ${output.scriptPubKey}`,
          affectedOutputs: [index]
        });
      }
    });

    return vulnerabilities;
  }

  private static async detectDustAttacks(transaction: BitcoinTransaction): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const dustThreshold = 0.00000546; // 546 satoshis

    transaction.outputs.forEach((output, index) => {
      if (output.value > 0 && output.value < dustThreshold) {
        vulnerabilities.push({
          type: 'dust_attack',
          severity: 'low',
          description: 'Dust attack output detected',
          details: `Dust output found at index ${index} with value: ${output.value} BTC`,
          affectedOutputs: [index],
          amount_btc: output.value
        });
      }
    });

    return vulnerabilities;
  }

  private static async detectAddressReuse(transaction: BitcoinTransaction): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const addressMap = new Map<string, number[]>();

    transaction.outputs.forEach((output, index) => {
      if (output.decodedScript && output.decodedScript.length > 2) {
        const address = output.decodedScript[2]; // Heuristic for P2PKH address
        if (address) {
          if (!addressMap.has(address)) {
            addressMap.set(address, []);
          }
          addressMap.get(address)!.push(index);
        }
      }
    });

    for (const [address, outputIndices] of addressMap.entries()) {
      if (outputIndices.length > 1) {
        vulnerabilities.push({
          type: 'address_reuse',
          severity: 'medium',
          description: 'Address reuse detected',
          details: `Address ${address} reused in outputs ${outputIndices.join(', ')}`,
          affectedOutputs: outputIndices,
          addresses: [address]
        });
      }
    }

    return vulnerabilities;
  }

  private static async detectRValueReuse(transaction: BitcoinTransaction): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const rValueMap = new Map<string, { inputIndex: number; signature: ECDSASignature }[]>();

    // Group signatures by r-value
    transaction.inputs.forEach((input, inputIndex) => {
      if (input.signatures) {
        input.signatures.forEach(signature => {
          if (!rValueMap.has(signature.r)) {
            rValueMap.set(signature.r, []);
          }
          rValueMap.get(signature.r)!.push({ inputIndex, signature });
        });
      }
    });

    // Check for reused r-values
    for (const [rValue, signatures] of rValueMap.entries()) {
      if (signatures.length > 1) {
        console.log(`ðŸš¨ R-value reuse detected: ${rValue}`);
        
        // Attempt private key recovery
        const signaturePair = {
          sig1: signatures[0].signature,
          sig2: signatures[1].signature,
          hash1: `mock_hash_1_${transaction.txid}`,
          hash2: `mock_hash_2_${transaction.txid}`,
          txid1: transaction.txid,
          txid2: transaction.txid
        };

        const recoveryResult = await PrivateKeyRecovery.recoverPrivateKeyFromReuse(signaturePair);
        
        let description = `R-value reuse detected in transaction ${transaction.txid}. Same r-value used in ${signatures.length} signatures.`;
        let details = `Affected inputs: ${signatures.map(s => s.inputIndex).join(', ')}. R-value: ${rValue}`;
        
        if (recoveryResult.success) {
          description += ' CRITICAL: Private key has been mathematically recovered!';
          details += `\n\nðŸ”“ RECOVERED PRIVATE KEY:\nHex: ${recoveryResult.privateKeyHex}\nWIF: ${recoveryResult.privateKeyWIF}`;
          
          console.log(`ðŸ’¥ CRITICAL VULNERABILITY: Private key recovered!`);
          console.log(`ðŸ”‘ Private Key (Hex): ${recoveryResult.privateKeyHex}`);
          console.log(`ðŸ”‘ Private Key (WIF): ${recoveryResult.privateKeyWIF}`);
        } else if (recoveryResult.error) {
          details += `\nPrivate key recovery attempted but failed: ${recoveryResult.error}`;
        }

        vulnerabilities.push({
          type: 'r_reuse',
          severity: recoveryResult.success ? 'critical' : 'high',
          description,
          details,
          affectedInputs: signatures.map(s => s.inputIndex),
          rValue,
          privateKeyRecovered: recoveryResult.success,
          privateKeyHex: recoveryResult.success ? recoveryResult.privateKeyHex : undefined,
          privateKeyWIF: recoveryResult.success ? recoveryResult.privateKeyWIF : undefined
        });
      }
    }

    return vulnerabilities;
  }
}
